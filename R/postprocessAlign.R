#' Creates cumulative times for each drug in the drug record
#' @param drugRec A drug record
#' @export
#' @return A data.table object with drugs
#'
createDrugDF <- function(drugRec){
  drugDF <- as.data.frame(t(as.data.frame(drugRec, col.names = c(seq(1:length(drugRec))))))
  names(drugDF) <- c("t_gap", "component")
  drugDF[1,]$t_gap <- 0

  # Assign each individual drug an occurrence period of roughly one day
  drugDF$t_start <- cumsum(drugDF$t_gap)
  drugDF$index <- 1:length(drugDF$t_gap)

  return(drugDF)

}

#' Calculates the number of unique aligned drugs in a regimen
#'
no_unique_aligned_drugs <- function(regimen) {
    s = gsub("[0-9]*\\.", "", regimen)
    
    s = unlist(strsplit(s, ";|~"))
    s = s[s!="__"]

    return(length(unique(s)))
}

#' Prepare data.frame for postproccessing. 
#' Adds cumulative times from drugDF to the dataframe,
#' where each regimen starts and ends
#' @param df A dataframe with drugRec_Start and drugRec_End columns
#' @param drugDF A drugDF object generated by createDrugDF()
#' @return A data.table object without removed overlaps
#' 
add_cumultive_times_to_df <- function(df, drugDF) {
    # Ensure drugRec_Start and drugRec_End are within valid range
    df <- df %>%
      dplyr::mutate(drugRec_Start = pmax(drugRec_Start, 1),
                    drugRec_End   = pmin(drugRec_End, max(drugDF$index))
      )
 
    # Add cumulative times to the dataframe
    df$t_start <- drugDF[df$drugRec_Start,]$t_start
    df$t_end <- drugDF[df$drugRec_End,]$t_start
    
    return(df)
}

#' Removes overlapping regimens from alignment output
#'
#' Three overlap removal steps are performed:
#' #' 1. Remove overlaps between regimens with different names  
#' #' 2. Remove overlaps between regimens with different number of components
#' #' 3. Remove overlaps between regimens with the same name, same total alignment length, but different scores
#' @param df A dataframe created by align() with cumulative times added by add_cumultive_times_to_df()
#' @export
#' @return A data.table object without removed overlaps
#' @importFrom data.table :=
#' @importFrom data.table .I
#' 
removeOverlaps <- function(df) {
    # get number of components in each regimen variant
    regCount <- df %>%
        dplyr::rowwise() %>%
        dplyr::mutate(
            compNo = no_unique_aligned_drugs(Regimen) 
        ) %>%
        dplyr::select(regName, Regimen, compNo) %>% 
        dplyr::distinct()

    # Convert to data.table to do overlap and drop lower scored regimens
    data.table::setDT(df)
    data.table::setorder(df, drugRec_Start, drugRec_End)
    df[, index := .I]
    
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, drugRec_Start, drugRec_End)
    
    # Find overlaps where regName is different
    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("drugRec_Start", "drugRec_End"), 
                          by.y = c("drugRec_Start", "drugRec_End"))
    overlaps <- overlaps[regName != i.regName & index < i.index]
    removed <- integer(0)
    
    # Process overlaps row-wise and remove lower scored regimens
    for (row in seq_len(nrow(overlaps))) {
        i <- overlaps$index[row]
        j <- overlaps$i.index[row]
        
        if (i %in% removed || j %in% removed) next
        
        i_score <- overlaps$adjustedS[row]
        j_score <- overlaps$i.adjustedS[row]
        
        if (i_score < j_score) {
            removed <- c(removed, i)
        } else if (j_score < i_score) {
            removed <- c(removed, j)
        }
    }
    
    df <- df[!index %in% removed]
    df[, index := NULL]

    # SECOND overlap removal - removing low component high scoring regimens
    # compNo - number of components
    data.table::setDT(regCount)
    df <- merge(df, regCount, by = c("regName", "Regimen"))
    df[, index := .I]
    data.table::setorder(df, t_start, t_end)
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, t_start, t_end)

    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("t_start", "t_end"), 
                          by.y = c("t_start", "t_end"))
    
    # Exclude self-overlaps
    overlaps <- overlaps[index != i.index]
    toRemove <- overlaps[compNo != i.compNo, 
                         .(remove = ifelse(compNo < i.compNo, index, i.index))]$remove
    
    df <- df[!index %in% toRemove]
    
    # Final overlap removal - sub-regimens
    # Ensure sorted order for foverlaps
    
    data.table::setorder(df, t_start, t_end)
    df_overlap <- data.table::copy(df)
    data.table::setkey(df_overlap, t_start, t_end)
    
    # Find overlapping intervals
    overlaps <- data.table::foverlaps(df, df_overlap, nomatch = 0, 
                          by.x = c("t_start", "t_end"), 
                          by.y = c("t_start", "t_end"))
    
    # Exclude self-overlaps and one position overlaps
    overlaps <- overlaps[index < i.index,]
    overlaps <- overlaps[t_start != i.t_end & t_end != i.t_start,]
    
    overlaps <- overlaps[regName == i.regName & totAlign == i.totAlign,]
    overlaps <- overlaps[adjustedS != i.adjustedS,]
    toRemove <- overlaps[,.(remove = ifelse(adjustedS < i.adjustedS, index, i.index))]$remove
    
    df <- df[!index %in% toRemove][order(t_start)]
    df[, index := NULL]
    df <- as.data.frame(df)
    return(df)
}

#' Combines overlapping regimens from alignment output
#' We only merge same regimens, next to each other chronologically
#' We sort chronologically
#' Create id for consecutive regimens and remove if distance is larger than regimenCombine
#' @param output An output dataframe created by align()
#' @param regimenCombine Allowed days between same regimen before being combined
#' @export
#' 
combineOverlaps <- function(df, regimenCombine) {
    dt <- df
    data.table::setDT(dt)
    # TODO: remove regName to disable regimen overlap 
    data.table::setorder(dt, regName, t_start, t_end)

    dt[, run_id := cumsum(
        c(TRUE, regName[-1] != regName[-.N] | (t_start[-1] - t_end[-.N]) >= regimenCombine)
    )]
    
    dt <- dt[, .(
              drugRec_Start = min(drugRec_Start),
              drugRec_End   = max(drugRec_End),
              t_start       = min(t_start),
              t_end         = max(t_end),
              adjustedS     = mean(adjustedS),
              Score         = mean(Score),
              totAlign      = sum(totAlign)
            ), by = .(personID, regName, run_id)
            ][, run_id := NULL][, component := regName]


      return(as.data.frame(dt))
}


#' Postprocess alignment output
#'
#' @param output An output dataframe created by align()
#' @param regimenCombine Allowed number of days between two instances of the same regimen before
#' @return df - A data.frame object
#' @export
#' 
postprocessDF <- function(output, regimenCombine = 28) {
    # Remove rows with NA score and low scoring or one drug alignments  
    df <- output %>% 
        dplyr::filter(totAlign > 1 & adjustedS > 0.501)

    if (nrow(df) == 0) {
        return(data.frame())
    }  

    # Use patient drug record to create cumulative times
    # Assume drug record is the same for all rows
    drugRec <- encode(df$DrugRecord_full[1])
    drugDF <- createDrugDF(drugRec)

    df <- add_cumultive_times_to_df(df, drugDF)    
    df <- removeOverlaps(df)
    df <- combineOverlaps(df, regimenCombine)

    # Calculate time to next regimen, 0 if negative
    df$timeToNextRegimen <- 0
    df$timeToEOD <- 0
  
    df <- df %>%
        dplyr::arrange(t_start) %>%
        dplyr::mutate(timeToNextRegimen = pmax(0, dplyr::lead(t_start) - t_end)) %>%
        dplyr::mutate(regLength = (t_end - t_start) + 1)    

    endOfData <- max(drugDF$t_start)
    df[nrow(df),]$timeToEOD <- endOfData - df[nrow(df),]$t_end

  return(df)                
}